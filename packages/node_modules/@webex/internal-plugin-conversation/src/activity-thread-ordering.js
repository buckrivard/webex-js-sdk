import {sortBy, last} from 'lodash';

export const defaultMinDisplayableActivities = 20;
export const minBatchSize = 10;
export const fetchLoopCountMax = 100;
export const batchSizeIncrementCount = 10;

export const OLDER = 'older';
export const NEWER = 'newer';
export const MID = 'mid';
export const INITIAL = 'initial';

export const ACTIVITY_TYPES = {
  REPLY: 'REPLY',
  EDIT: 'EDIT',
  REACTION: 'REACTION',
  REACTION_SELF: 'REACTION_SELF',
  ROOT: 'ROOT',
  CREATE: 'CREATE',
  TOMBSTONE: 'TOMBSTONE',
  DELETE: 'DELETE'
};

// TODO: create type for tombstone edit? could make it easy to ignore older edits...
export const getActivityType = (activity) => {
  if (activity.activityType === 'reply') {
    return ACTIVITY_TYPES.REPLY;
  }
  if (activity.parent && activity.parent.type === 'edit') {
    return ACTIVITY_TYPES.EDIT;
  }
  if (activity.verb === 'add' || activity.type === 'reactionSummary') {
    return ACTIVITY_TYPES.REACTION;
  }
  if (activity.type === 'reactionSelfSummary') {
    return ACTIVITY_TYPES.REACTION_SELF;
  }
  if (activity.verb === 'create') {
    return ACTIVITY_TYPES.CREATE;
  }
  if (activity.verb === 'tombstone') {
    return ACTIVITY_TYPES.TOMBSTONE;
  }
  if (activity.verb === 'delete') {
    return ACTIVITY_TYPES.DELETE;
  }

  return ACTIVITY_TYPES.ROOT;
};

export const getPublishedDate = (activity = {}) => new Date(activity.published).getTime();

/**
 * @param {Object} activity1
 * @param {Object} activity2
 * @returns {boolean} true if first activity is newer than second
 */
export const isNewer = (activity1, activity2) => getPublishedDate(activity1) > getPublishedDate(activity2);

export const getActivityObjectsFromMap = (hashMap) => Array.from(hashMap).map(([, activity]) => activity);

export const sortActivitiesByPublishedDate = (activities) => sortBy(activities, (activity) => getPublishedDate(activity));

export const getParentId = (activity) => activity && activity.parent && activity.parent.id;

export const isRootActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.ROOT;
export const isReplyActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.REPLY;
export const isEditActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.EDIT;
export const isCreateActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.CREATE;
export const isDeleteActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.DELETE;

export const sanitizeActivity = (activity) => {
  const final = {...activity};

  final.reaction = activity.reaction || {};
  final.reactionSelf = activity.reactionSelf || {};

  // replies will be spread in order beneath parent, no need to include on final objects
  delete final.replies;

  return final;
};

/**
 * encapsulates state and logic for managing oldest and newest activities
 * @returns {object} setters and getters for activity state management
 */
export const bookendManager = () => {
  // keep track of generator state, like what our current oldest & newest activities are
  let oldestAct;
  let newestAct;

  const getOldestAct = () => oldestAct;
  const getNewestAct = () => newestAct;

  const setOldestAct = (act) => {
    if (!oldestAct) {
      oldestAct = act;
    }
    else if (isNewer(oldestAct, act)) {
      oldestAct = act;
    }
  };

  const setNewestAct = (act) => {
    if (!newestAct) {
      newestAct = act;
    }
    else if (isNewer(act, newestAct)) {
      newestAct = act;
    }
  };

  const setBookends = (activities) => {
    const oldestActsFirst = sortActivitiesByPublishedDate(activities);

    const newestInBatch = last(oldestActsFirst);
    const oldestInBatch = oldestActsFirst[0];

    setOldestAct(oldestInBatch);
    setNewestAct(newestInBatch);
  };

  return {
    setBookends,
    getNewestAct,
    getOldestAct
  };
};

export const noMoreActivitiesManager = () => {
  // used to determine if we should continue to fetch older activities
  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached
  let noMoreActs = false;
  let noOlderActs = false;
  let noNewerActs = false;

  const getNoMoreActs = () => noMoreActs;

  const checkAndSetNoOlderActs = (act) => {
    if (!noOlderActs && getActivityType(act) === ACTIVITY_TYPES.CREATE) {
      noOlderActs = true;
    }
  };

  const checkAndSetNoNewerActs = (activities) => {
    if (!activities || !activities.length) {
      noNewerActs = true;
    }
  };

  const checkAndSetNoMoreActs = (queryType) => {
    if (
      (queryType === NEWER && noNewerActs) ||
      ((queryType === OLDER || queryType === INITIAL) && noOlderActs)
    ) {
      noMoreActs = true;
    }
  };

  return {
    getNoMoreActs,
    checkAndSetNoMoreActs,
    checkAndSetNoNewerActs,
    checkAndSetNoOlderActs
  };
};

// use accessors for ease of refactoring underlying implementation
/**
       * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.
       * @param {string} key
       * @param {any} value
       * @returns {Map}
       */
export const setValue = (destination, key, value) => destination.set(key, value);
/**
       * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type
       * @param {string} key
       * @returns {Map}
       */
export const getValue = (source, key) => source.get(key);
