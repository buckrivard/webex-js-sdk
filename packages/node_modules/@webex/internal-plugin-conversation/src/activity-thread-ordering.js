import {sortBy, last} from 'lodash';

// use accessors for ease of refactoring underlying implementation
/**
       * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.
       * @param {string} key
       * @param {any} value
       * @returns {Map}
       */
export const setValue = (destination, key, value) => destination.set(key, value);
/**
             * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type
             * @param {string} key
             * @returns {Map}
             */
export const getValue = (source, key) => source.get(key);

export const defaultMinDisplayableActivities = 20;
export const minBatchSize = 10;
export const fetchLoopCountMax = 100;
export const batchSizeIncrementCount = 10;

export const OLDER = 'older';
export const NEWER = 'newer';
export const MID = 'mid';
export const INITIAL = 'initial';

export const ACTIVITY_TYPES = {
  REPLY: 'REPLY',
  EDIT: 'EDIT',
  REACTION: 'REACTION',
  REACTION_SELF: 'REACTION_SELF',
  ROOT: 'ROOT',
  CREATE: 'CREATE',
  TOMBSTONE: 'TOMBSTONE',
  DELETE: 'DELETE'
};

// TODO: create type for tombstone edit? could make it easy to ignore older edits...
export const getActivityType = (activity) => {
  if (activity.activityType === 'reply') {
    return ACTIVITY_TYPES.REPLY;
  }
  if (activity.parent && activity.parent.type === 'edit') {
    return ACTIVITY_TYPES.EDIT;
  }
  if (activity.verb === 'add' || activity.type === 'reactionSummary') {
    return ACTIVITY_TYPES.REACTION;
  }
  if (activity.type === 'reactionSelfSummary') {
    return ACTIVITY_TYPES.REACTION_SELF;
  }
  if (activity.verb === 'create') {
    return ACTIVITY_TYPES.CREATE;
  }
  if (activity.verb === 'tombstone') {
    return ACTIVITY_TYPES.TOMBSTONE;
  }
  if (activity.verb === 'delete') {
    return ACTIVITY_TYPES.DELETE;
  }

  return ACTIVITY_TYPES.ROOT;
};

export const getPublishedDate = (activity = {}) => new Date(activity.published).getTime();

/**
 * @param {Object} activity1
 * @param {Object} activity2
 * @returns {boolean} true if first activity is newer than second
 */
export const isNewer = (activity1, activity2) => getPublishedDate(activity1) > getPublishedDate(activity2);

export const getActivityObjectsFromMap = (hashMap) => Array.from(hashMap).map(([, activity]) => activity);

export const sortActivitiesByPublishedDate = (activities) => sortBy(activities, (activity) => getPublishedDate(activity));

export const getParentId = (activity) => activity && activity.parent && activity.parent.id;

export const isRootActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.ROOT;
export const isReplyActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.REPLY;
export const isEditActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.EDIT;
export const isCreateActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.CREATE;
export const isDeleteActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.DELETE;

export const sanitizeActivity = (activity) => {
  const final = {...activity};

  final.reaction = activity.reaction || {};
  final.reactionSelf = activity.reactionSelf || {};

  // replies will be spread in order beneath parent, no need to include on final objects
  delete final.replies;

  return final;
};

export const activityManager = () => {
  const replyActivityHash = new Map();
  const editActivityHash = new Map();
  const reactionActivityHash = new Map();
  const reactionSelfActivityHash = new Map();

  const getActivityByTypeAndId = (type, id) => ({
    [ACTIVITY_TYPES.EDIT]: getValue(editActivityHash, id),
    [ACTIVITY_TYPES.REPLY]: getValue(replyActivityHash, id),
    [ACTIVITY_TYPES.REACTION]: getValue(reactionActivityHash, id),
    [ACTIVITY_TYPES.REACTION_SELF]: getValue(reactionSelfActivityHash, id)
  }[type]);

  const handleNewReply = (replyAct) => {
    const replyParentId = getParentId(replyAct);
    const existingReplyHash = getValue(replyActivityHash, replyParentId);

    if (existingReplyHash) {
      setValue(existingReplyHash, replyAct.id, replyAct);
    }
    else {
      const replyHash = new Map();

      setValue(replyHash, replyAct.id, replyAct);
      setValue(replyActivityHash, replyParentId, replyHash);
    }
  };

  const handleNewEdit = (editAct) => {
    const isTombstone = editAct.verb === ACTIVITY_TYPES.TOMBSTONE;

    // we can ignore tombstone edits in favor of the newer one
    if (isTombstone) {
      return;
    }

    const editParentId = getParentId(editAct);
    const existingEdit = getValue(editActivityHash, editParentId);

    // edited activity must be newer than what we already have
    if (!existingEdit || isNewer(editAct, existingEdit)) {
      setValue(editActivityHash, editParentId, editAct);
    }
  };

  // logic is identical between reactions and reaction selfs, so handler simply passes the activity and the correct hash
  const reactionHelper = (reactionAct, hash) => {
    const reactionParentId = getParentId(reactionAct);
    const existingReaction = getValue(hash, reactionParentId);

    // reaction activity must be newer than what we already have
    if (!existingReaction || isNewer(reactionAct, existingReaction)) {
      setValue(hash, reactionParentId, reactionAct);
    }
  };

  const handleNewReaction = (reactionAct) => {
    reactionHelper(reactionAct, reactionActivityHash);
  };

  const handleNewReactionSelf = (reactionSelfAct) => {
    reactionHelper(reactionSelfAct, reactionSelfActivityHash);
  };

  const getActivityHandlerByKey = (key) => ({
    [ACTIVITY_TYPES.REACTION]: handleNewReaction,
    [ACTIVITY_TYPES.REACTION_SELF]: handleNewReactionSelf,
    [ACTIVITY_TYPES.EDIT]: handleNewEdit,
    [ACTIVITY_TYPES.REPLY]: handleNewReply
  }[key]);

  return {
    getActivityHandlerByKey,
    getActivityByTypeAndId
  };
};

/**
 * encapsulates state and logic for managing oldest and newest activities
 * @returns {object} setters and getters for activity state management
 */
export const bookendManager = () => {
  // keep track of generator state, like what our current oldest & newest activities are
  let oldestAct;
  let newestAct;

  const getOldestAct = () => oldestAct;
  const getNewestAct = () => newestAct;

  const setOldestAct = (act) => {
    if (!oldestAct) {
      oldestAct = act;
    }
    else if (isNewer(oldestAct, act)) {
      oldestAct = act;
    }
  };

  const setNewestAct = (act) => {
    if (!newestAct) {
      newestAct = act;
    }
    else if (isNewer(act, newestAct)) {
      newestAct = act;
    }
  };

  const setBookends = (activities) => {
    const oldestActsFirst = sortActivitiesByPublishedDate(activities);

    const newestInBatch = last(oldestActsFirst);
    const oldestInBatch = oldestActsFirst[0];

    setOldestAct(oldestInBatch);
    setNewestAct(newestInBatch);
  };

  return {
    setBookends,
    getNewestAct,
    getOldestAct
  };
};

export const noMoreActivitiesManager = () => {
  // used to determine if we should continue to fetch older activities
  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached
  let noMoreActs = false;
  let noOlderActs = false;
  let noNewerActs = false;

  const getNoMoreActs = () => noMoreActs;

  const checkAndSetNoOlderActs = (act) => {
    if (!noOlderActs && getActivityType(act) === ACTIVITY_TYPES.CREATE) {
      noOlderActs = true;
    }
  };

  const checkAndSetNoNewerActs = (activities) => {
    if (!activities || !activities.length) {
      noNewerActs = true;
    }
  };

  const checkAndSetNoMoreActs = (queryType) => {
    if (
      (queryType === NEWER && noNewerActs) ||
      ((queryType === OLDER || queryType === INITIAL) && noOlderActs)
    ) {
      noMoreActs = true;
    }
  };

  return {
    getNoMoreActs,
    checkAndSetNoMoreActs,
    checkAndSetNoNewerActs,
    checkAndSetNoOlderActs
  };
};

export const rootActivityManager = () => {
  const rootActivityHash = new Map();
  const handleNewRoot = (rootAct) => {
    setValue(rootActivityHash, rootAct.id, rootAct);
  };

  const getRootActivityHash = () => rootActivityHash;

  return {
    handleNewRoot,
    getRootActivityHash
  };
};

/**
 * creates activity query object
 * @param {string} type type of query to create
 * @param {object} queryOptions options to define query
 * @param {string} [queryOptions.newestPublishedDate] the date of the newest fetched activity
 * @param {string} [queryOptions.oldestPublishedDate] the date of the oldest fetched activity
 * @param {number} [queryOptions.batchSize] the number of activities to query
 * @param {object} [queryOptions.activityToSearch] a server activity to use to build middate query
 * @returns {object}
 */
export const getQuery = (type, queryOptions) => {
  const {
    newestPublishedDate, oldestPublishedDate, batchSize, activityToSearch = {}
  } = queryOptions;

  switch (type) {
    case NEWER: {
      const sinceDate = newestPublishedDate + 1;
      const lastActivityFirst = false;

      return {sinceDate, lastActivityFirst};
    }
    case MID: {
      const searchType = getActivityType(activityToSearch);
      let midDate;

      if (searchType === ACTIVITY_TYPES.REPLY || searchType === ACTIVITY_TYPES.EDIT) {
        midDate = activityToSearch.parent.published;
      }
      else {
        midDate = activityToSearch.published;
      }

      return {midDate, limit: batchSize};
    }
    case OLDER: {
      const maxDate = oldestPublishedDate - 1;

      return {maxDate};
    }
    case INITIAL:
    default: {
      return {};
    }
  }
};
